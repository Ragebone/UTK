# Roadmap

Where this project is headed.

## In no particular order

- [x] Initial shallow implementation down to the UEFI volume level 
- [x] Rough implementation down to UEFI files and sections, even compressed ones
- [x] Basic-ish documentation in README.md files
- [x] UEFI GUID database and name support
- [x] Intermediate format; Python Dictionaries with `toDict(self) -> dict[str, Any]`
- [x] ~~Intermediate format JSON serialization via toJson() methods~~
- [ ] Full UEFI implementation on par with UEFITool
      - Some parts are still horrible
      - More Capsule-Headers need supporting 
  - Fully understand, parse and use those headers
      - More Volumes, file-systems, and other specifics are still needed
- [ ] Full implementation down to decompression and compression
      - Blocked by proper compression of LZMA compressed Sections
        Compressing is easy, but does it work still work?
        the new compressed binary is completely different to the previous one.
        That breaks the tests at minimum.

- [ ] Full feature parity to the amdfwtool used by / for coreboot 
- [ ] Proper Capsule handling with an interface and multiple Classes for the different capsules and then sub structures

- [ ] (Flash) Offset remembering and pass through in fromBinary() 
- [ ] GUID management framework
- [ ] Strings search in framework
- [ ] Deterministic export to and import from a directory structure
- [ ] Implement UEFI checksum calculations and verification
  - [x] Implement UEFI volume-header crc16 calculations
    - [ ] TODO: proper "verification" functionality 
    
- [ ] Crypto system for signature management, verification and signing
- [ ] AMD flavored firmware handling
  - [ ] AMD PSP EFS detection and construction
  - [ ] AMD PSP directories
  - [ ] AMD PSP firmware
  - [ ] AMD PSP structure manipulation and rebuilding
  - [ ] AMD PSP firmware signature verification
  - [ ] AMD PSP firmware signature resigning

- [ ] Intel flavored firmware handling
- [ ] HII capability
- [ ] PCD capability
- [ ] NVAR Capability
- [ ] Address and referencing framework  References is what it is gona be called, probably
- [ ] Support for emulation and further automation
- [ ] Package release for easy usage
- [ ] Support advanced firmware analysis
- [ ] Integrate with QEMU
- [ ] Integrate with other tools
- [ ] Integrate with EMBA
- [ ] Support emulation
- [ ] Support proxy execution and debugging
- [ ] Actual tools and use-cases
  - Info printing;   tools/info.py  something like the report generated by the UEFITools UEFIExtract -r
  - Extract everything to directories
  - Extract something specific
  - Rebuild 
  - Replace something(s) by its GUID
  - Unlocking hidden bios options
    - Unlocking AMD CBS for instance
  - Adding new settings / menus to the UEFI user interface
  - Changing default bios settings

  - Others? 

## Roadmap-ed use-cases 

One still open question here is how to properly use those pieces of python code.

To envision a few possibilities:


#### Get me what ever is at offset 0x21000

```python
from UtkBase.biosFile import BiosFile
bios = BiosFile.fromFilepath("./Pro-WS-WRX80E-SAGE-SE-WIFI-ASUS-1003.CAP")

objectAtOffset = bios.getObjectAt(0x21000)
```

In this specific showcase, the object should be an AMD specific structure that isn't implemented yet.
Neither is the functionality to get something at an offset.
To add to this idea, the offset should result in the same object as long as the object is the smallest known thing at location. 
And as long as the offset is within the objects bounds.

#### Batch replacements by GUID and from a reference

This would need to be implemented as a separate tool in `tools/`.
But once there is a list of objects that have UefiGuids, it could look like this:

```python
from UtkBase.biosFile import BiosFile
bios = BiosFile.fromFilepath("./Pro-WS-WRX80E-SAGE-SE-WIFI-ASUS-1003.CAP")
listOfThingsToReplace = ['objects that have GUIDs, pulled from another Bios / image']
bios.replace(listOfThingsToReplace)
```

Maybe instead of a list, have it be a dictionary that directly maps GUID strings to the object to be replaced.

#### Insert, Add, Remove things

Inserting, adding and removing something, anything really, is the obvious and most relevant use-case.
One important decision already is to not expose the datastructures for manual alterations like that.
That is because checksums and others details might need to be adjusted in order to nor break the firmware.
Instead, fitting methods need to handle such details when altering.
